{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Inicio","text":"<p>Informe de avances.</p>"},{"location":"#introduccion-y-objetivos","title":"Introducci\u00f3n y Objetivos","text":""},{"location":"#jornada-de-salud","title":"Jornada de Salud","text":"<p>Con el objeto de favorecer las competencias espec\u00edficas planteadas en el perfil del egresado de la Licenciatura en Bioinform\u00e1tica (FIUNER), el presente trabajo busca abordar un  problema de asignaci\u00f3n de especies cr\u00edpticas de inter\u00e9s epidemiol\u00f3gico en la regi\u00f3n del litoral argentino. </p>"},{"location":"#desarrollo-y-resultados","title":"Desarrollo y Resultados","text":""},{"location":"#analisis-en-2-dimensiones-2d","title":"An\u00e1lisis en 2 Dimensiones (2D)","text":"<p>En base a caracteres morfol\u00f3gicos discretos o el an\u00e1lisis univariado de variables escalares, una nueva especie de murci\u00e9lago del g\u00e9nero Molossus -definida gen\u00e9ticamente - no pod\u00eda ser operativamente diferenciada de otros 3 mol\u00f3ssidos que cohabitan en la regi\u00f3n central. A partir de este planteo, en base a criterios de factibilidad, los estudiantes lograron identificar, seleccionar cr\u00edticamente, implementar y testear comparativamente una bater\u00eda de m\u00e9todos de adquisici\u00f3n y an\u00e1lisis de datos multidimensionales de morfometr\u00eda craneal basados en medidas lineales (Fig1) y landmarks en im\u00e1genes 2D (Fig2) y objetos 3D obtenidos mediante fotogrametr\u00eda digital.</p> <p></p> <p></p>"},{"location":"#analisis-en-3-dimensiones-3d","title":"An\u00e1lisis en 3 Dimensiones (3D)","text":"<p>Para proceder con el estudio morfom\u00e9trico en 3D se recurri\u00f3 a t\u00e9cnicas de fotometr\u00eda digital para obtener un modelo tridimensional del cr\u00e1neo. </p>"},{"location":"#fotometria-digital","title":"Fotometr\u00eda digital","text":"<p>Como modelo de pruebas para ajustar el procedimiento, se emple\u00f3 el modelo de un cr\u00e1neo de murci\u00e9lago p\u00e1lido (Antrozous pallidus) de libre uso. El mismo se encuentra disponible en thingiverse.com. El modelo fue escalado para ajustarse al tama\u00f1o del cr\u00e1neo de Molossus. </p> <p></p> <p>Se requiri\u00f3 de un Setup de pruebas que permitiera tomar fotograf\u00edas de manera autom\u00e1tica. Se realizaron las pruebas de concepto con motores paso a paso y una placa de desarrollo Arduino:</p> <p></p> <p>Posteriormente se prob\u00f3 emplear una c\u00e1mara web USB:</p> <p></p> <p>Pruebas con caja de iluminaci\u00f3n:</p> <p></p>"},{"location":"#escaner-3d","title":"Escaner 3D","text":"<p>Para mejorar la repetibilidad del escaneo de los cr\u00e1neos, se opt\u00f3 por modificar un modelo de escaner 3D por fotometr\u00eda de OpenScan en su versi\u00f3n cl\u00e1sica. El mismo puede ser impreso mediante una impresora 3D con tecnolog\u00eda FDM, y los archivos se encuentran disponibles en thingiverse.com.</p> <p>Para el modelado de piezas personalizadas se emple\u00f3 el software Open Source FreeCAD.</p> <p></p> <p>Las piezas fueron impresas en una impresora 3D Hellbot Magna 1v2 usando filamento PLA.</p> <p></p> <p>El ensamblado final de todas las partes:</p> <p></p> <p>Durante la prueba del esc\u00e1ner, se ejecuta una rutina de escaneo dise\u00f1ada para capturar im\u00e1genes tridimensionales con precisi\u00f3n. Esta rutina comienza con un giro completo de 360\u00b0 de la pieza en intervalos de 15\u00b0, deteni\u00e9ndose en cada paso para la toma de las fotograf\u00edas correspondientes. Posteriormente, el brazo lateral del esc\u00e1ner se inclina en un \u00e1ngulo de 60\u00b0 en ambas direcciones, con incrementos de 20\u00b0 en cada movimiento. Cada vez que el brazo lateral se inclina, se realiza un giro completo de la pieza en escaneo, asegurando una cobertura exhaustiva del objeto en estudio.</p> <p></p>"},{"location":"#procesado-de-imagenes","title":"Procesado de Im\u00e1genes","text":""},{"location":"#acondicionamiento","title":"Acondicionamiento","text":"<p>Para el preprocesamiento y acondicionamiento de las im\u00e1genes del escaneo, se emple\u00f3 el programa de manipulaci\u00f3n de im\u00e1genes de GNU, GIMP. Se a\u00f1adi\u00f3 la extensi\u00f3n Batch Image Manipulation para aplicar el procesamiento en masa.</p> <p>El acondicionamiento incluye etapas de:</p> <ul> <li>Recorte</li> <li> <p>cortar a relaci\u00f3n de aspecto est\u00e1ndar (1:1)</p> </li> <li> <p>Correcci\u00f3n de color</p> </li> <li>convertir a escala de grises</li> <li> <p>correcci\u00f3n autom\u00e1tica de los niveles de color</p> </li> <li> <p>Renombrar con un patr\u00f3n</p> </li> </ul> <p></p>"},{"location":"#reconstruccion-3d","title":"Reconstrucci\u00f3n 3D","text":"<p>Se trabaj\u00f3 con el programa de reconstrucci\u00f3n 3D Open Source Meshroom. Se cargaron las im\u00e1genes de cada escaneo al programa y se ajustan los par\u00e1metros del flujo de trabajo.</p> <p></p> <p></p>"},{"location":"#codigo-arduino","title":"C\u00f3digo arduino","text":"<p>El siguiente c\u00f3digo se emplea para controlar todo el setup de escaneo:</p> Escaner-fotometr\u00eda.ino<pre><code>#include &lt;AccelStepper.h&gt;\n#include &lt;Wire.h&gt; \n#include &lt;LiquidCrystal_I2C.h&gt;\n\n// stepper motor 28byj-48 \nconst int STEPS_PER_REVOLUTION = 2038;  // change this to fit the number of steps per revolution\n\n// Base Giratoria\nconst int PHOTOSTEP = 85; // 2048 steps / 360\u00b0 = 5.68 steps/\u00b0 --&gt; 15\u00b0 = 85.2 steps\nconst int FULL_TURN = 24;\nconst int ANGLE_BASE = 15;\n\n// Brazo\nconst int ARMSTEP = 114; // 2048 steps / 360\u00b0 = 5.68 steps/\u00b0 --&gt; 20\u00b0 = 113.6 steps\nconst int ANGLE_ARM = 20;\n\n// Motor 1 --&gt; Base giratoria\n// Motor 2 --&gt; Brazo\n\n// ULN2003 Motor 1 Driver Pins\n#define IN1_1 8\n#define IN2_1 9\n#define IN3_1 10\n#define IN4_1 11\n\n// ULN2003 Motor 2 Driver Pins\n#define IN1_2 4\n#define IN2_2 5\n#define IN3_2 6\n#define IN4_2 7\n\n// Joystick Pins\n#define JOYSTICK_X A1\n#define JOYSTICK_Y A0\n#define JOYSTICK_THRESHOLD 50\n\n// initialize the motor interface\nAccelStepper Motor_1(AccelStepper::HALF4WIRE, IN1_1, IN3_1, IN2_1, IN4_1);\nAccelStepper Motor_2(AccelStepper::HALF4WIRE, IN1_2, IN3_2, IN2_2, IN4_2);\n\n// Button\n#define BUTTON_JOYSTICK 12\n\n\n// Define la direcci\u00f3n I2C del LCD\n#define I2C_ADDR 0x27\n\n// Define las dimensiones del LCD\n#define LCD_WIDTH 16\n#define LCD_HEIGHT 2\n\n// Inicializa el objeto LiquidCrystal_I2C\nLiquidCrystal_I2C lcd(I2C_ADDR, LCD_WIDTH, LCD_HEIGHT);\n\nvoid setup() {\n  // set the maximum speed, acceleration factor,\n    // initial speed and the target position\n  Motor_1.setMaxSpeed(1000);\n  Motor_1.setAcceleration(200);\n  //Motor_1.setSpeed(200);\n\n  Motor_2.setMaxSpeed(1000);\n  Motor_2.setAcceleration(500);\n  //Motor_2.setSpeed(200);\n\n  // initialize the button pin as input\n  pinMode(BUTTON_JOYSTICK, INPUT_PULLUP);\n\n  // initialize the serial port\n  Serial.begin(9600);\n\n  // Inicializa el LCD utilizando I2C\n  lcd.init();\n  lcd.backlight(); // Enciende la retroiluminaci\u00f3n\n\n  PantallaInicio();\n\n}\n\n// ==============================================================\n\nvoid loop() {\n  // Leer los valores del joystick\n  int joyX = analogRead(JOYSTICK_X);\n  //delay(100);\n  int joyY = analogRead(JOYSTICK_Y);\n  //delay(100);\n  bool buttonValue = digitalRead(BUTTON_JOYSTICK);\n\n  // Mover el brazo hacia adelante o hacia atr\u00e1s\n  if (abs(joyX - 512) &gt; JOYSTICK_THRESHOLD) {\n    if (joyX &lt; 512) {\n      MoverBrazo(-ANGLE_ARM);\n      PantallaInicio();\n    } else {\n      MoverBrazo(ANGLE_ARM);\n      PantallaInicio();\n    }\n  }\n\n  // Girar la base hacia la izquierda\n  if (abs(joyY - 512) &gt; JOYSTICK_THRESHOLD &amp;&amp; joyY &gt; 512) {\n    GirarBaseCompleta();\n    PantallaInicio();\n  }\n\n  // Espera a que se presione el bot\u00f3n\n  if ( buttonValue == LOW) {\n    lcd.clear();\n    lcd.setCursor(0, 0); \n    lcd.print(\"   Realizar\");\n    lcd.setCursor(0, 1); \n    lcd.print(\"  Escaneo...\");\n    delay(1000);\n\n    RealizarEscaneo(); // Funci\u00f3n para realizar el escaneo completo\n\n    lcd.clear();\n    lcd.setCursor(0, 0); \n    lcd.print(\"   Escaneo\");\n    lcd.setCursor(0, 1); \n    lcd.print(\"  Completado!\");\n  }\n\n\n\n} // fin loop\n\n// ==============================================================\n\n// Funci\u00f3n para realizar los movimientos\nvoid RealizarEscaneo() {\n// Se mueve para atr\u00e1s\n  for (int i = 0; i &lt; 3; i++) {\n    GirarBaseCompleta();\n    MoverBrazo(-ANGLE_ARM);\n  }\n\n// Vuelve al medio\n  for (int i = 0; i &lt; 3; i++) {\n    MoverBrazo(ANGLE_ARM);\n  }\n\n// Se mueve para adelante\n  for (int i = 0; i &lt; 3; i++) {\n    MoverBrazo(ANGLE_ARM);\n    GirarBaseCompleta();\n  }\n\n// Vuelve al medio\n  for (int i = 0; i &lt; 3; i++) {\n    MoverBrazo(-ANGLE_ARM);\n  }\n}\n\n// Funci\u00f3n para girar la base completa\nvoid GirarBaseCompleta() {\n  lcd.clear();\n  lcd.setCursor(0, 0);\n  lcd.print(\"Girando base...\");\n\n  for (int i = 0; i &lt;= FULL_TURN; i++) {\n    lcd.setCursor(0, 1); \n    lcd.print(String(\"vuelta: \") + String(i) + String(\" de 24\"));\n    Motor_1.move(ANGLE_BASE*2 * (STEPS_PER_REVOLUTION / 360)); //el 2 es para compensar por manejar en medio paso el motor\n    Motor_1.runToPosition();\n    delay(500);\n  }\n}\n\n// Funci\u00f3n para mover el brazo\nvoid MoverBrazo(int angle) {\n  lcd.clear();\n  lcd.setCursor(0, 0);\n  lcd.print(angle &gt; 0 ? \"Girando +brazo...\" : \"Girando -brazo...\");\n  lcd.setCursor(0, 1); \n  lcd.print(String(\"paso: \") + String(ANGLE_ARM) + String(\" grados\"));\n\n  Motor_2.move(angle * (STEPS_PER_REVOLUTION / 360));\n  Motor_2.runToPosition();\n  delay(1000);\n}\n\n// Funci\u00f3n para reinciar LCD\n\nvoid PantallaInicio(){\n  // set the cursor to column 0, line 1\n  // (note: line 1 is the second row, since counting begins with 0)\n  lcd.clear();\n  lcd.setCursor(0, 0); \n  lcd.print(\"   Fotometria\");\n  lcd.setCursor(0, 1); \n  lcd.print(\"Elija opcion...\");\n}\n</code></pre>"},{"location":"page2/","title":"P\u00e1gina 2","text":""},{"location":"page2/#work-in-progress","title":"Work in progress","text":"<p>Coming soon...</p>"}]}